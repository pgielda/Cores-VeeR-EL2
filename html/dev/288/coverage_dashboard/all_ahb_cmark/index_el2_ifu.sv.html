<!DOCTYPE HTML>
<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>
        Full
        coverage report
    </title>
    <link rel="stylesheet" type="text/css" href="cov.css">
    <style>
        .container {
            background-color: rgb(169, 169, 169);
            width: 100%;
            min-height: 80%;
            border-radius: 15px;
        }
    </style>
</head>

<body>
    <table class="title-header-shadow">
        <td class="title-container">
            <table class="title-header">
                <td class="title-logo">
                    <a href=index.html>
                        <img src=_static/white.svg></img>
                    </a>
                </td>
                <td class="title">
                    Project
                    Full
                    coverage report
                </td>
            </table>
        </td>
    </table>
    <center>
        <table class="info-table">
            <tr class="info-table-view">
                <td width="10%" class="headerInfo">Current view:</td>
                <td width="40%" class="headerInfoValue">
                    <a href=index.html>Cores-VeeR-EL2</a>—Cores-VeeR-EL2—design—ifu—el2_ifu.sv
                </td>
                <td width=auto></td>
                <td width="10%"></td>
                <td width="10%" class="headerCovSummary colTop">Coverage</td>
                <td width="10%" class="headerCovSummary colTop" title="Covered + Uncovered code">Hit</td>
                <td width="10%" class="headerCovSummary colTop" title="Exercised code only">Total</td>
            </tr>
            <tr>
                <td class="headerInfo">Test Date:</td>
                <td class="headerInfoValue">
                    10-12-2024
                </td>
                <td></td>
                
    <td class="headerCovSummary rowLeft">
        Toggle
    </td>
    <td class="headerCovSummaryEntry" style="color: #0E1116; background-color: #f6ff00;">
        51.7%
    </td>
    <td class="headerCovSummaryEntry">
        76
    </td>
    <td class="headerCovSummaryEntry">
        147
    </td>

            </tr>
            <tr>
                <td class="headerInfo">Test:</td>
                <td class="headerInfoValue">
                    ahb_cmark
                </td>
                <td></td>
                
    <td class="headerCovSummary rowLeft">
        Branch
    </td>
    <td class="headerCovSummaryEntry" style="color: #0E1116; background-color: #a9a9a9;">
        0.0%
    </td>
    <td class="headerCovSummaryEntry">
        0
    </td>
    <td class="headerCovSummaryEntry">
        0
    </td>

            </tr>
            
        </table>
    </center>

    <table border="0" cellpadding="0" cellspacing="0">
<tr>
<td><br/></td>
</tr>
<tr>
<td>
<pre class="sourceHeading">            Line data    Source code</pre>
<pre class="source">
<span id="L1"><span class="lineNum">       1</span>              : //********************************************************************************</span>
<span id="L2"><span class="lineNum">       2</span>              : // SPDX-License-Identifier: Apache-2.0</span>
<span id="L3"><span class="lineNum">       3</span>              : // Copyright 2020 Western Digital Corporation or its affiliates.</span>
<span id="L4"><span class="lineNum">       4</span>              : //</span>
<span id="L5"><span class="lineNum">       5</span>              : // Licensed under the Apache License, Version 2.0 (the "License");</span>
<span id="L6"><span class="lineNum">       6</span>              : // you may not use this file except in compliance with the License.</span>
<span id="L7"><span class="lineNum">       7</span>              : // You may obtain a copy of the License at</span>
<span id="L8"><span class="lineNum">       8</span>              : //</span>
<span id="L9"><span class="lineNum">       9</span>              : // http://www.apache.org/licenses/LICENSE-2.0</span>
<span id="L10"><span class="lineNum">      10</span>              : //</span>
<span id="L11"><span class="lineNum">      11</span>              : // Unless required by applicable law or agreed to in writing, software</span>
<span id="L12"><span class="lineNum">      12</span>              : // distributed under the License is distributed on an "AS IS" BASIS,</span>
<span id="L13"><span class="lineNum">      13</span>              : // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span id="L14"><span class="lineNum">      14</span>              : // See the License for the specific language governing permissions and</span>
<span id="L15"><span class="lineNum">      15</span>              : // limitations under the License.</span>
<span id="L16"><span class="lineNum">      16</span>              : //********************************************************************************</span>
<span id="L17"><span class="lineNum">      17</span>              : //********************************************************************************</span>
<span id="L18"><span class="lineNum">      18</span>              : // Function: Top level file for Icache, Fetch, Branch prediction &amp; Aligner</span>
<span id="L19"><span class="lineNum">      19</span>              : // BFF -&gt; F1 -&gt; F2 -&gt; A</span>
<span id="L20"><span class="lineNum">      20</span>              : //********************************************************************************</span>
<span id="L21"><span class="lineNum">      21</span>              : </span>
<span id="L22"><span class="lineNum">      22</span>              : module el2_ifu</span>
<span id="L23"><span class="lineNum">      23</span>              : import el2_pkg::*;</span>
<span id="L24"><span class="lineNum">      24</span>              : #(</span>
<span id="L25"><span class="lineNum">      25</span>              : `include "el2_param.vh"</span>
<span id="L26"><span class="lineNum">      26</span>              :  )</span>
<span id="L27"><span class="lineNum">      27</span>              :   (</span>
<span id="L28"><span class="lineNum">      28</span> <span class="tlaGNC tlaBgGNC">     4822318 :    input logic free_l2clk,                   // Clock always.                  Through one clock header.  For flops with    second header built in.</span></span>
<span id="L29"><span class="lineNum">      29</span> <span class="tlaGNC">     4822318 :    input logic active_clk,                   // Clock only while core active.  Through two clock headers. For flops without second clock header built in.</span></span>
<span id="L30"><span class="lineNum">      30</span> <span class="tlaGNC">     4822318 :    input logic clk,                          // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.</span></span>
<span id="L31"><span class="lineNum">      31</span> <span class="tlaGNC">           3 :    input logic rst_l,                        // reset, active low</span></span>
<span id="L32"><span class="lineNum">      32</span>              : </span>
<span id="L33"><span class="lineNum">      33</span> <span class="tlaGNC">      186659 :    input logic dec_i0_decode_d,              // Valid instruction at D and not blocked</span></span>
<span id="L34"><span class="lineNum">      34</span>              : </span>
<span id="L35"><span class="lineNum">      35</span> <span class="tlaGNC">       34552 :    input logic exu_flush_final, // flush, includes upper and lower</span></span>
<span id="L36"><span class="lineNum">      36</span> <span class="tlaGNC">      186568 :    input logic dec_tlu_i0_commit_cmt , // committed i0</span></span>
<span id="L37"><span class="lineNum">      37</span> <span class="tlaUNC tlaBgUNC">           0 :    input logic dec_tlu_flush_err_wb , // flush due to parity error.</span></span>
<span id="L38"><span class="lineNum">      38</span> <span class="tlaGNC tlaBgGNC">          12 :    input logic dec_tlu_flush_noredir_wb, // don't fetch, validated with exu_flush_final</span></span>
<span id="L39"><span class="lineNum">      39</span> <span class="tlaGNC">       14332 :    input logic [31:1] exu_flush_path_final, // flush fetch address</span></span>
<span id="L40"><span class="lineNum">      40</span>              : </span>
<span id="L41"><span class="lineNum">      41</span> <span class="tlaUNC tlaBgUNC">           0 :    input logic [31:0]  dec_tlu_mrac_ff ,// Side_effect , cacheable for each region</span></span>
<span id="L42"><span class="lineNum">      42</span> <span class="tlaUNC">           0 :    input logic         dec_tlu_fence_i_wb, // fence.i, invalidate icache, validated with exu_flush_final</span></span>
<span id="L43"><span class="lineNum">      43</span> <span class="tlaUNC">           0 :    input logic         dec_tlu_flush_leak_one_wb, // ignore bp for leak one fetches</span></span>
<span id="L44"><span class="lineNum">      44</span>              : </span>
<span id="L45"><span class="lineNum">      45</span> <span class="tlaUNC">           0 :    input logic                       dec_tlu_bpred_disable,     // disable all branch prediction</span></span>
<span id="L46"><span class="lineNum">      46</span> <span class="tlaUNC">           0 :    input logic                       dec_tlu_core_ecc_disable,  // disable ecc checking and flagging</span></span>
<span id="L47"><span class="lineNum">      47</span> <span class="tlaUNC">           0 :    input logic                       dec_tlu_force_halt,        // force halt</span></span>
<span id="L48"><span class="lineNum">      48</span>              : </span>
<span id="L49"><span class="lineNum">      49</span>              :   //-------------------------- IFU AXI signals--------------------------</span>
<span id="L50"><span class="lineNum">      50</span>              :    // AXI Write Channels</span>
<span id="L51"><span class="lineNum">      51</span>              :    /* exclude signals that are tied to constant value in el2_ifu_mem_ctl.sv */</span>
<span id="L52"><span class="lineNum">      52</span>              :    /*verilator coverage_off*/</span>
<span id="L53"><span class="lineNum">      53</span>              :    output logic                            ifu_axi_awvalid,</span>
<span id="L54"><span class="lineNum">      54</span>              :    output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_awid,</span>
<span id="L55"><span class="lineNum">      55</span>              :    output logic [31:0]                     ifu_axi_awaddr,</span>
<span id="L56"><span class="lineNum">      56</span>              :    output logic [3:0]                      ifu_axi_awregion,</span>
<span id="L57"><span class="lineNum">      57</span>              :    output logic [7:0]                      ifu_axi_awlen,</span>
<span id="L58"><span class="lineNum">      58</span>              :    output logic [2:0]                      ifu_axi_awsize,</span>
<span id="L59"><span class="lineNum">      59</span>              :    output logic [1:0]                      ifu_axi_awburst,</span>
<span id="L60"><span class="lineNum">      60</span>              :    output logic                            ifu_axi_awlock,</span>
<span id="L61"><span class="lineNum">      61</span>              :    output logic [3:0]                      ifu_axi_awcache,</span>
<span id="L62"><span class="lineNum">      62</span>              :    output logic [2:0]                      ifu_axi_awprot,</span>
<span id="L63"><span class="lineNum">      63</span>              :    output logic [3:0]                      ifu_axi_awqos,</span>
<span id="L64"><span class="lineNum">      64</span>              : </span>
<span id="L65"><span class="lineNum">      65</span>              :    output logic                            ifu_axi_wvalid,</span>
<span id="L66"><span class="lineNum">      66</span>              :    output logic [63:0]                     ifu_axi_wdata,</span>
<span id="L67"><span class="lineNum">      67</span>              :    output logic [7:0]                      ifu_axi_wstrb,</span>
<span id="L68"><span class="lineNum">      68</span>              :    output logic                            ifu_axi_wlast,</span>
<span id="L69"><span class="lineNum">      69</span>              : </span>
<span id="L70"><span class="lineNum">      70</span>              :    output logic                            ifu_axi_bready,</span>
<span id="L71"><span class="lineNum">      71</span>              :    /*verilator coverage_on*/</span>
<span id="L72"><span class="lineNum">      72</span>              : </span>
<span id="L73"><span class="lineNum">      73</span>              :    // AXI Read Channels</span>
<span id="L74"><span class="lineNum">      74</span> <span class="tlaGNC tlaBgGNC">      123420 :    output logic                            ifu_axi_arvalid,</span></span>
<span id="L75"><span class="lineNum">      75</span> <span class="tlaGNC">      123421 :    input  logic                            ifu_axi_arready,</span></span>
<span id="L76"><span class="lineNum">      76</span> <span class="tlaGNC">      163580 :    output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_arid,</span></span>
<span id="L77"><span class="lineNum">      77</span> <span class="tlaGNC">       59814 :    output logic [31:0]                     ifu_axi_araddr,</span></span>
<span id="L78"><span class="lineNum">      78</span> <span class="tlaGNC">          12 :    output logic [3:0]                      ifu_axi_arregion,</span></span>
<span id="L79"><span class="lineNum">      79</span>              :    /* exclude signals that are tied to constant value in el2_ifu_mem_ctl.sv */</span>
<span id="L80"><span class="lineNum">      80</span>              :    /*verilator coverage_off*/</span>
<span id="L81"><span class="lineNum">      81</span>              :    output logic [7:0]                      ifu_axi_arlen,</span>
<span id="L82"><span class="lineNum">      82</span>              :    output logic [2:0]                      ifu_axi_arsize,</span>
<span id="L83"><span class="lineNum">      83</span>              :    output logic [1:0]                      ifu_axi_arburst,</span>
<span id="L84"><span class="lineNum">      84</span>              :    output logic                            ifu_axi_arlock,</span>
<span id="L85"><span class="lineNum">      85</span>              :    output logic [3:0]                      ifu_axi_arcache,</span>
<span id="L86"><span class="lineNum">      86</span>              :    output logic [2:0]                      ifu_axi_arprot,</span>
<span id="L87"><span class="lineNum">      87</span>              :    output logic [3:0]                      ifu_axi_arqos,</span>
<span id="L88"><span class="lineNum">      88</span>              :    /*verilator coverage_on*/</span>
<span id="L89"><span class="lineNum">      89</span>              : </span>
<span id="L90"><span class="lineNum">      90</span> <span class="tlaGNC">      246837 :    input  logic                            ifu_axi_rvalid,</span></span>
<span id="L91"><span class="lineNum">      91</span>              :    /* exclude signals that are tied to constant value in el2_ifu_mem_ctl.sv */</span>
<span id="L92"><span class="lineNum">      92</span>              :    /*verilator coverage_off*/</span>
<span id="L93"><span class="lineNum">      93</span>              :    output logic                            ifu_axi_rready,</span>
<span id="L94"><span class="lineNum">      94</span>              :    /*verilator coverage_on*/</span>
<span id="L95"><span class="lineNum">      95</span> <span class="tlaGNC">      132820 :    input  logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_rid,</span></span>
<span id="L96"><span class="lineNum">      96</span> <span class="tlaGNC">      115627 :    input  logic [63:0]                     ifu_axi_rdata,</span></span>
<span id="L97"><span class="lineNum">      97</span> <span class="tlaUNC tlaBgUNC">           0 :    input  logic [1:0]                      ifu_axi_rresp,</span></span>
<span id="L98"><span class="lineNum">      98</span>              : </span>
<span id="L99"><span class="lineNum">      99</span> <span class="tlaGNC tlaBgGNC">           3 :    input  logic                      ifu_bus_clk_en,</span></span>
<span id="L100"><span class="lineNum">     100</span>              : </span>
<span id="L101"><span class="lineNum">     101</span> <span class="tlaUNC tlaBgUNC">           0 :    input  logic                      dma_iccm_req,</span></span>
<span id="L102"><span class="lineNum">     102</span> <span class="tlaUNC">           0 :    input  logic [31:0]               dma_mem_addr,</span></span>
<span id="L103"><span class="lineNum">     103</span> <span class="tlaUNC">           0 :    input  logic [2:0]                dma_mem_sz,</span></span>
<span id="L104"><span class="lineNum">     104</span> <span class="tlaUNC">           0 :    input  logic                      dma_mem_write,</span></span>
<span id="L105"><span class="lineNum">     105</span> <span class="tlaUNC">           0 :    input  logic [63:0]               dma_mem_wdata,</span></span>
<span id="L106"><span class="lineNum">     106</span> <span class="tlaUNC">           0 :    input  logic [2:0]                dma_mem_tag,       //  DMA Buffer entry number</span></span>
<span id="L107"><span class="lineNum">     107</span>              : </span>
<span id="L108"><span class="lineNum">     108</span>              : </span>
<span id="L109"><span class="lineNum">     109</span> <span class="tlaUNC">           0 :    input  logic                      dma_iccm_stall_any,</span></span>
<span id="L110"><span class="lineNum">     110</span> <span class="tlaUNC">           0 :    output logic                      iccm_dma_ecc_error,</span></span>
<span id="L111"><span class="lineNum">     111</span> <span class="tlaUNC">           0 :    output logic                      iccm_dma_rvalid,</span></span>
<span id="L112"><span class="lineNum">     112</span> <span class="tlaUNC">           0 :    output logic [63:0]               iccm_dma_rdata,</span></span>
<span id="L113"><span class="lineNum">     113</span> <span class="tlaUNC">           0 :    output logic [2:0]                iccm_dma_rtag,     //   Tag of the DMA req</span></span>
<span id="L114"><span class="lineNum">     114</span> <span class="tlaGNC tlaBgGNC">       17589 :    output logic                      iccm_ready,</span></span>
<span id="L115"><span class="lineNum">     115</span>              : </span>
<span id="L116"><span class="lineNum">     116</span> <span class="tlaGNC">      186659 :    output logic       ifu_pmu_instr_aligned,</span></span>
<span id="L117"><span class="lineNum">     117</span> <span class="tlaGNC">      113520 :    output logic       ifu_pmu_fetch_stall,</span></span>
<span id="L118"><span class="lineNum">     118</span> <span class="tlaUNC tlaBgUNC">           0 :    output logic       ifu_ic_error_start,     // has all of the I$ ecc/parity for data/tag</span></span>
<span id="L119"><span class="lineNum">     119</span>              : </span>
<span id="L120"><span class="lineNum">     120</span>              : //   I$ &amp; ITAG Ports</span>
<span id="L121"><span class="lineNum">     121</span> <span class="tlaGNC tlaBgGNC">          26 :    output logic [31:1]               ic_rw_addr,         // Read/Write addresss to the Icache.</span></span>
<span id="L122"><span class="lineNum">     122</span> <span class="tlaGNC">      246303 :    output logic [pt.ICACHE_NUM_WAYS-1:0]                ic_wr_en,           // Icache write enable, when filling the Icache.</span></span>
<span id="L123"><span class="lineNum">     123</span> <span class="tlaGNC">      327716 :    output logic                      ic_rd_en,           // Icache read  enable.</span></span>
<span id="L124"><span class="lineNum">     124</span>              : </span>
<span id="L125"><span class="lineNum">     125</span> <span class="tlaGNC">       57836 :    output logic [pt.ICACHE_BANKS_WAY-1:0][70:0]               ic_wr_data,         // Data to fill to the Icache. With ECC</span></span>
<span id="L126"><span class="lineNum">     126</span> <span class="tlaGNC">      143899 :    input  logic [63:0]              ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC</span></span>
<span id="L127"><span class="lineNum">     127</span> <span class="tlaUNC tlaBgUNC">           0 :    input  logic [70:0]              ic_debug_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC</span></span>
<span id="L128"><span class="lineNum">     128</span> <span class="tlaUNC">           0 :    input  logic [25:0]                     ictag_debug_rd_data,// Debug icache tag.</span></span>
<span id="L129"><span class="lineNum">     129</span> <span class="tlaUNC">           0 :    output logic [70:0]               ic_debug_wr_data,   // Debug wr cache.</span></span>
<span id="L130"><span class="lineNum">     130</span>              : </span>
<span id="L131"><span class="lineNum">     131</span> <span class="tlaUNC">           0 :    output logic [70:0]               ifu_ic_debug_rd_data,</span></span>
<span id="L132"><span class="lineNum">     132</span>              : </span>
<span id="L133"><span class="lineNum">     133</span> <span class="tlaUNC">           0 :    input  logic [pt.ICACHE_BANKS_WAY-1:0] ic_eccerr,    //</span></span>
<span id="L134"><span class="lineNum">     134</span> <span class="tlaUNC">           0 :    input  logic [pt.ICACHE_BANKS_WAY-1:0] ic_parerr,</span></span>
<span id="L135"><span class="lineNum">     135</span> <span class="tlaGNC tlaBgGNC">      143899 :    output logic [63:0]               ic_premux_data,     // Premux data to be muxed with each way of the Icache.</span></span>
<span id="L136"><span class="lineNum">     136</span> <span class="tlaGNC">      204152 :    output logic                      ic_sel_premux_data, // Select the premux data.</span></span>
<span id="L137"><span class="lineNum">     137</span>              : </span>
<span id="L138"><span class="lineNum">     138</span> <span class="tlaUNC tlaBgUNC">           0 :    output logic [pt.ICACHE_INDEX_HI:3]               ic_debug_addr,      // Read/Write addresss to the Icache.</span></span>
<span id="L139"><span class="lineNum">     139</span> <span class="tlaUNC">           0 :    output logic                      ic_debug_rd_en,     // Icache debug rd</span></span>
<span id="L140"><span class="lineNum">     140</span> <span class="tlaUNC">           0 :    output logic                      ic_debug_wr_en,     // Icache debug wr</span></span>
<span id="L141"><span class="lineNum">     141</span> <span class="tlaUNC">           0 :    output logic                      ic_debug_tag_array, // Debug tag array</span></span>
<span id="L142"><span class="lineNum">     142</span> <span class="tlaUNC">           0 :    output logic [pt.ICACHE_NUM_WAYS-1:0]                ic_debug_way,       // Debug way. Rd or Wr.</span></span>
<span id="L143"><span class="lineNum">     143</span>              : </span>
<span id="L144"><span class="lineNum">     144</span>              : </span>
<span id="L145"><span class="lineNum">     145</span> <span class="tlaGNC tlaBgGNC">      315345 :    output logic [pt.ICACHE_NUM_WAYS-1:0]                ic_tag_valid,       // Valid bits when accessing the Icache. One valid bit per way. F2 stage</span></span>
<span id="L146"><span class="lineNum">     146</span>              : </span>
<span id="L147"><span class="lineNum">     147</span> <span class="tlaUNC tlaBgUNC">           0 :    input  logic [pt.ICACHE_NUM_WAYS-1:0]                ic_rd_hit,          // Compare hits from Icache tags. Per way.  F2 stage</span></span>
<span id="L148"><span class="lineNum">     148</span> <span class="tlaUNC">           0 :    input  logic                      ic_tag_perr,        // Icache Tag parity error</span></span>
<span id="L149"><span class="lineNum">     149</span>              : </span>
<span id="L150"><span class="lineNum">     150</span>              : </span>
<span id="L151"><span class="lineNum">     151</span>              :    // ICCM ports</span>
<span id="L152"><span class="lineNum">     152</span> <span class="tlaGNC tlaBgGNC">         228 :    output logic [pt.ICCM_BITS-1:1]               iccm_rw_addr,       // ICCM read/write address.</span></span>
<span id="L153"><span class="lineNum">     153</span> <span class="tlaUNC tlaBgUNC">           0 :    output logic                      iccm_wren,          // ICCM write enable (through the DMA)</span></span>
<span id="L154"><span class="lineNum">     154</span> <span class="tlaGNC tlaBgGNC">       66450 :    output logic                      iccm_rden,          // ICCM read enable.</span></span>
<span id="L155"><span class="lineNum">     155</span> <span class="tlaUNC tlaBgUNC">           0 :    output logic [77:0]               iccm_wr_data,       // ICCM write data.</span></span>
<span id="L156"><span class="lineNum">     156</span> <span class="tlaUNC">           0 :    output logic [2:0]                iccm_wr_size,       // ICCM write location within DW.</span></span>
<span id="L157"><span class="lineNum">     157</span>              : </span>
<span id="L158"><span class="lineNum">     158</span> <span class="tlaGNC tlaBgGNC">       67756 :    input  logic [63:0]               iccm_rd_data,       // Data read from ICCM.</span></span>
<span id="L159"><span class="lineNum">     159</span> <span class="tlaGNC">       79909 :    input  logic [77:0]               iccm_rd_data_ecc,   // Data + ECC read from ICCM.</span></span>
<span id="L160"><span class="lineNum">     160</span>              : </span>
<span id="L161"><span class="lineNum">     161</span>              :    // ICCM ECC status</span>
<span id="L162"><span class="lineNum">     162</span> <span class="tlaUNC tlaBgUNC">           0 :    output logic                      ifu_iccm_dma_rd_ecc_single_err, // This fetch has a single ICCM DMA ECC error.</span></span>
<span id="L163"><span class="lineNum">     163</span> <span class="tlaUNC">           0 :    output logic                      ifu_iccm_rd_ecc_single_err,     // This fetch has a single ICCM ECC error.</span></span>
<span id="L164"><span class="lineNum">     164</span> <span class="tlaUNC">           0 :    output logic                      ifu_iccm_rd_ecc_double_err,     // This fetch has a double ICCM ECC error.</span></span>
<span id="L165"><span class="lineNum">     165</span>              : </span>
<span id="L166"><span class="lineNum">     166</span>              : // Perf counter sigs</span>
<span id="L167"><span class="lineNum">     167</span> <span class="tlaGNC tlaBgGNC">      123422 :    output logic       ifu_pmu_ic_miss, // ic miss</span></span>
<span id="L168"><span class="lineNum">     168</span> <span class="tlaUNC tlaBgUNC">           0 :    output logic       ifu_pmu_ic_hit, // ic hit</span></span>
<span id="L169"><span class="lineNum">     169</span> <span class="tlaUNC">           0 :    output logic       ifu_pmu_bus_error, // iside bus error</span></span>
<span id="L170"><span class="lineNum">     170</span> <span class="tlaUNC">           0 :    output logic       ifu_pmu_bus_busy,  // iside bus busy</span></span>
<span id="L171"><span class="lineNum">     171</span> <span class="tlaGNC tlaBgGNC">      123420 :    output logic       ifu_pmu_bus_trxn, // iside bus transactions</span></span>
<span id="L172"><span class="lineNum">     172</span>              : </span>
<span id="L173"><span class="lineNum">     173</span>              : </span>
<span id="L174"><span class="lineNum">     174</span> <span class="tlaUNC tlaBgUNC">           0 :    output logic       ifu_i0_icaf,         // Instruction 0 access fault. From Aligner to Decode</span></span>
<span id="L175"><span class="lineNum">     175</span> <span class="tlaUNC">           0 :    output logic [1:0] ifu_i0_icaf_type, // Instruction 0 access fault type</span></span>
<span id="L176"><span class="lineNum">     176</span>              : </span>
<span id="L177"><span class="lineNum">     177</span> <span class="tlaGNC tlaBgGNC">      184861 :    output logic  ifu_i0_valid,        // Instruction 0 valid. From Aligner to Decode</span></span>
<span id="L178"><span class="lineNum">     178</span> <span class="tlaUNC tlaBgUNC">           0 :    output logic  ifu_i0_icaf_second,  // Instruction 0 has access fault on second 2B of 4B inst</span></span>
<span id="L179"><span class="lineNum">     179</span> <span class="tlaUNC">           0 :    output logic  ifu_i0_dbecc,        // Instruction 0 has double bit ecc error</span></span>
<span id="L180"><span class="lineNum">     180</span> <span class="tlaUNC">           0 :    output logic  iccm_dma_sb_error,   // Single Bit ECC error from a DMA access</span></span>
<span id="L181"><span class="lineNum">     181</span> <span class="tlaGNC tlaBgGNC">       27900 :    output logic[31:0] ifu_i0_instr,   // Instruction 0 . From Aligner to Decode</span></span>
<span id="L182"><span class="lineNum">     182</span> <span class="tlaGNC">          15 :    output logic[31:1] ifu_i0_pc,      // Instruction 0 pc. From Aligner to Decode</span></span>
<span id="L183"><span class="lineNum">     183</span> <span class="tlaGNC">      249903 :    output logic ifu_i0_pc4,           // Instruction 0 is 4 byte. From Aligner to Decode</span></span>
<span id="L184"><span class="lineNum">     184</span>              : </span>
<span id="L185"><span class="lineNum">     185</span> <span class="tlaGNC">       78190 :    output logic ifu_miss_state_idle,   // There is no outstanding miss. Cache miss state is idle.</span></span>
<span id="L186"><span class="lineNum">     186</span>              : </span>
<span id="L187"><span class="lineNum">     187</span> <span class="tlaGNC">        1014 :    output el2_br_pkt_t i0_brp,           // Instruction 0 branch packet. From Aligner to Decode</span></span>
<span id="L188"><span class="lineNum">     188</span> <span class="tlaGNC">       20222 :    output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ifu_i0_bp_index, // BP index</span></span>
<span id="L189"><span class="lineNum">     189</span> <span class="tlaGNC">       65687 :    output logic [pt.BHT_GHR_SIZE-1:0] ifu_i0_bp_fghr, // BP FGHR</span></span>
<span id="L190"><span class="lineNum">     190</span> <span class="tlaGNC">        2328 :    output logic [pt.BTB_BTAG_SIZE-1:0] ifu_i0_bp_btag, // BP tag</span></span>
<span id="L191"><span class="lineNum">     191</span> <span class="tlaUNC tlaBgUNC">           0 :    output logic [$clog2(pt.BTB_SIZE)-1:0]         ifu_i0_fa_index,          // Fully associt btb index</span></span>
<span id="L192"><span class="lineNum">     192</span>              : </span>
<span id="L193"><span class="lineNum">     193</span> <span class="tlaGNC tlaBgGNC">        6066 :    input el2_predict_pkt_t  exu_mp_pkt, // mispredict packet</span></span>
<span id="L194"><span class="lineNum">     194</span> <span class="tlaGNC">       18446 :    input logic [pt.BHT_GHR_SIZE-1:0] exu_mp_eghr, // execute ghr</span></span>
<span id="L195"><span class="lineNum">     195</span> <span class="tlaGNC">       64677 :    input logic [pt.BHT_GHR_SIZE-1:0]  exu_mp_fghr,                    // Mispredict fghr</span></span>
<span id="L196"><span class="lineNum">     196</span> <span class="tlaGNC">       14052 :    input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  exu_mp_index,         // Mispredict index</span></span>
<span id="L197"><span class="lineNum">     197</span> <span class="tlaGNC">       13046 :    input logic [pt.BTB_BTAG_SIZE-1:0]  exu_mp_btag,                   // Mispredict btag</span></span>
<span id="L198"><span class="lineNum">     198</span>              : </span>
<span id="L199"><span class="lineNum">     199</span> <span class="tlaGNC">          92 :    input el2_br_tlu_pkt_t dec_tlu_br0_r_pkt, // slot0 update/error pkt</span></span>
<span id="L200"><span class="lineNum">     200</span> <span class="tlaGNC">       58673 :    input logic [pt.BHT_GHR_SIZE-1:0] exu_i0_br_fghr_r, // fghr to bp</span></span>
<span id="L201"><span class="lineNum">     201</span> <span class="tlaGNC">       15688 :    input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_i0_br_index_r, // bp index</span></span>
<span id="L202"><span class="lineNum">     202</span> <span class="tlaUNC tlaBgUNC">           0 :    input logic [$clog2(pt.BTB_SIZE)-1:0] dec_fa_error_index, // Fully associt btb error index</span></span>
<span id="L203"><span class="lineNum">     203</span>              : </span>
<span id="L204"><span class="lineNum">     204</span> <span class="tlaGNC tlaBgGNC">         228 :    input dec_tlu_flush_lower_wb,</span></span>
<span id="L205"><span class="lineNum">     205</span>              : </span>
<span id="L206"><span class="lineNum">     206</span> <span class="tlaGNC">      124478 :    output logic [15:0] ifu_i0_cinst,</span></span>
<span id="L207"><span class="lineNum">     207</span>              : </span>
<span id="L208"><span class="lineNum">     208</span> <span class="tlaGNC">          12 :     output logic [31:1] ifu_pmp_addr,</span></span>
<span id="L209"><span class="lineNum">     209</span> <span class="tlaUNC tlaBgUNC">           0 :     input  logic        ifu_pmp_error,</span></span>
<span id="L210"><span class="lineNum">     210</span>              : </span>
<span id="L211"><span class="lineNum">     211</span>              : /// Icache debug</span>
<span id="L212"><span class="lineNum">     212</span> <span class="tlaUNC">           0 :    input  el2_cache_debug_pkt_t        dec_tlu_ic_diag_pkt ,</span></span>
<span id="L213"><span class="lineNum">     213</span> <span class="tlaUNC">           0 :    output logic                    ifu_ic_debug_rd_data_valid,</span></span>
<span id="L214"><span class="lineNum">     214</span> <span class="tlaUNC">           0 :    output logic                                iccm_buf_correct_ecc,</span></span>
<span id="L215"><span class="lineNum">     215</span> <span class="tlaUNC">           0 :    output logic                                iccm_correction_state,</span></span>
<span id="L216"><span class="lineNum">     216</span>              : </span>
<span id="L217"><span class="lineNum">     217</span>              :    // Excluding scan_mode from coverage as its usage is determined by the integrator of the VeeR core.</span>
<span id="L218"><span class="lineNum">     218</span>              :    /*verilator coverage_off*/</span>
<span id="L219"><span class="lineNum">     219</span>              :    input logic scan_mode</span>
<span id="L220"><span class="lineNum">     220</span>              :    /*verilator coverage_on*/</span>
<span id="L221"><span class="lineNum">     221</span>              :    );</span>
<span id="L222"><span class="lineNum">     222</span>              : </span>
<span id="L223"><span class="lineNum">     223</span>              :    localparam TAGWIDTH = 2 ;</span>
<span id="L224"><span class="lineNum">     224</span>              :    localparam IDWIDTH  = 2 ;</span>
<span id="L225"><span class="lineNum">     225</span>              : </span>
<span id="L226"><span class="lineNum">     226</span> <span class="tlaGNC tlaBgGNC">       31100 :    logic                   ifu_fb_consume1, ifu_fb_consume2;</span></span>
<span id="L227"><span class="lineNum">     227</span> <span class="tlaGNC">          12 :    logic [31:1]            ifc_fetch_addr_f;</span></span>
<span id="L228"><span class="lineNum">     228</span> <span class="tlaGNC">          12 :    logic [31:1]            ifc_fetch_addr_bf;</span></span>
<span id="L229"><span class="lineNum">     229</span>              :   assign ifu_pmp_addr = ifc_fetch_addr_bf;</span>
<span id="L230"><span class="lineNum">     230</span>              : </span>
<span id="L231"><span class="lineNum">     231</span> <span class="tlaGNC">      261847 :    logic [1:0]   ifu_fetch_val;  // valids on a 2B boundary, left justified [7] implies valid fetch</span></span>
<span id="L232"><span class="lineNum">     232</span> <span class="tlaGNC">          12 :    logic [31:1]  ifu_fetch_pc;   // starting pc of fetch</span></span>
<span id="L233"><span class="lineNum">     233</span>              : </span>
<span id="L234"><span class="lineNum">     234</span> <span class="tlaUNC tlaBgUNC">           0 :    logic iccm_rd_ecc_single_err, iccm_dma_rd_ecc_single_err, ic_error_start;</span></span>
<span id="L235"><span class="lineNum">     235</span>              :    assign ifu_iccm_dma_rd_ecc_single_err = iccm_dma_rd_ecc_single_err;</span>
<span id="L236"><span class="lineNum">     236</span>              :    assign ifu_iccm_rd_ecc_single_err = iccm_rd_ecc_single_err;</span>
<span id="L237"><span class="lineNum">     237</span>              :    assign ifu_ic_error_start = ic_error_start;</span>
<span id="L238"><span class="lineNum">     238</span>              : </span>
<span id="L239"><span class="lineNum">     239</span>              : </span>
<span id="L240"><span class="lineNum">     240</span> <span class="tlaGNC tlaBgGNC">      284393 :    logic        ic_write_stall;</span></span>
<span id="L241"><span class="lineNum">     241</span> <span class="tlaUNC tlaBgUNC">           0 :    logic        ic_dma_active;</span></span>
<span id="L242"><span class="lineNum">     242</span> <span class="tlaGNC tlaBgGNC">       17603 :    logic        ifc_dma_access_ok;</span></span>
<span id="L243"><span class="lineNum">     243</span> <span class="tlaUNC tlaBgUNC">           0 :    logic [1:0]  ic_access_fault_f;</span></span>
<span id="L244"><span class="lineNum">     244</span> <span class="tlaUNC">           0 :    logic [1:0]  ic_access_fault_type_f;</span></span>
<span id="L245"><span class="lineNum">     245</span> <span class="tlaGNC tlaBgGNC">      202293 :    logic        ifu_ic_mb_empty;</span></span>
<span id="L246"><span class="lineNum">     246</span>              : </span>
<span id="L247"><span class="lineNum">     247</span> <span class="tlaGNC">      274143 :    logic ic_hit_f;</span></span>
<span id="L248"><span class="lineNum">     248</span>              : </span>
<span id="L249"><span class="lineNum">     249</span> <span class="tlaGNC">      270264 :    logic [1:0] ifu_bp_way_f; // way indication; right justified</span></span>
<span id="L250"><span class="lineNum">     250</span> <span class="tlaGNC">      130194 :    logic       ifu_bp_hit_taken_f; // kill next fetch; taken target found</span></span>
<span id="L251"><span class="lineNum">     251</span> <span class="tlaGNC">       34054 :    logic [31:1] ifu_bp_btb_target_f; //  predicted target PC</span></span>
<span id="L252"><span class="lineNum">     252</span> <span class="tlaGNC">       48315 :    logic        ifu_bp_inst_mask_f; // tell ic which valids to kill because of a taken branch; right justified</span></span>
<span id="L253"><span class="lineNum">     253</span> <span class="tlaGNC">      243083 :    logic [1:0]  ifu_bp_hist1_f; // history counters for all 4 potential branches; right justified</span></span>
<span id="L254"><span class="lineNum">     254</span> <span class="tlaGNC">      241938 :    logic [1:0]  ifu_bp_hist0_f; // history counters for all 4 potential branches; right justified</span></span>
<span id="L255"><span class="lineNum">     255</span> <span class="tlaGNC">       72678 :    logic [11:0] ifu_bp_poffset_f; // predicted target</span></span>
<span id="L256"><span class="lineNum">     256</span> <span class="tlaGNC">         668 :    logic [1:0]  ifu_bp_ret_f; // predicted ret ; right justified</span></span>
<span id="L257"><span class="lineNum">     257</span> <span class="tlaGNC">       59614 :    logic [1:0]  ifu_bp_pc4_f; // pc4 indication; right justified</span></span>
<span id="L258"><span class="lineNum">     258</span> <span class="tlaGNC">       74392 :    logic [1:0]  ifu_bp_valid_f; // branch valid, right justified</span></span>
<span id="L259"><span class="lineNum">     259</span> <span class="tlaGNC">       59835 :    logic [pt.BHT_GHR_SIZE-1:0] ifu_bp_fghr_f;</span></span>
<span id="L260"><span class="lineNum">     260</span> <span class="tlaUNC tlaBgUNC">           0 :    logic [1:0] [$clog2(pt.BTB_SIZE)-1:0] ifu_bp_fa_index_f;</span></span>
<span id="L261"><span class="lineNum">     261</span>              : </span>
<span id="L262"><span class="lineNum">     262</span>              : </span>
<span id="L263"><span class="lineNum">     263</span> <span class="tlaGNC tlaBgGNC">      261847 :    logic [1:0]   ic_fetch_val_f;</span></span>
<span id="L264"><span class="lineNum">     264</span> <span class="tlaGNC">      155701 :    logic [31:0] ic_data_f;</span></span>
<span id="L265"><span class="lineNum">     265</span> <span class="tlaGNC">      155701 :    logic [31:0] ifu_fetch_data_f;</span></span>
<span id="L266"><span class="lineNum">     266</span> <span class="tlaGNC">      423435 :    logic ifc_fetch_req_f;</span></span>
<span id="L267"><span class="lineNum">     267</span> <span class="tlaUNC tlaBgUNC">           0 :    logic ifc_fetch_req_f_raw;</span></span>
<span id="L268"><span class="lineNum">     268</span> <span class="tlaUNC">           0 :    logic iccm_dma_rd_ecc_double_err;</span></span>
<span id="L269"><span class="lineNum">     269</span> <span class="tlaUNC">           0 :    logic [1:0] iccm_rd_ecc_double_err;  // This fetch has an iccm double error.</span></span>
<span id="L270"><span class="lineNum">     270</span>              :    assign ifu_iccm_rd_ecc_double_err = |iccm_rd_ecc_double_err || |iccm_dma_rd_ecc_double_err;</span>
<span id="L271"><span class="lineNum">     271</span>              : </span>
<span id="L272"><span class="lineNum">     272</span> <span class="tlaUNC">           0 :    logic ifu_async_error_start;</span></span>
<span id="L273"><span class="lineNum">     273</span>              : </span>
<span id="L274"><span class="lineNum">     274</span>              : </span>
<span id="L275"><span class="lineNum">     275</span>              :    assign ifu_fetch_data_f[31:0] = ic_data_f[31:0];</span>
<span id="L276"><span class="lineNum">     276</span>              :    assign ifu_fetch_val[1:0] = ic_fetch_val_f[1:0];</span>
<span id="L277"><span class="lineNum">     277</span>              :    assign ifu_fetch_pc[31:1] = ifc_fetch_addr_f[31:1];</span>
<span id="L278"><span class="lineNum">     278</span>              : </span>
<span id="L279"><span class="lineNum">     279</span> <span class="tlaGNC tlaBgGNC">           6 :  logic                       ifc_fetch_uncacheable_bf;      // The fetch request is uncacheable space. BF stage</span></span>
<span id="L280"><span class="lineNum">     280</span> <span class="tlaGNC">      423436 :  logic                       ifc_fetch_req_bf;              // Fetch request. Comes with the address.  BF stage</span></span>
<span id="L281"><span class="lineNum">     281</span> <span class="tlaGNC">          15 :  logic                       ifc_fetch_req_bf_raw;          // Fetch request without some qualifications. Used for clock-gating. BF stage</span></span>
<span id="L282"><span class="lineNum">     282</span> <span class="tlaGNC">          32 :  logic                       ifc_iccm_access_bf;            // This request is to the ICCM. Do not generate misses to the bus.</span></span>
<span id="L283"><span class="lineNum">     283</span> <span class="tlaUNC tlaBgUNC">           0 :  logic                       ifc_region_acc_fault_bf;       // Access fault. in ICCM region but offset is outside defined ICCM.</span></span>
<span id="L284"><span class="lineNum">     284</span>              : </span>
<span id="L285"><span class="lineNum">     285</span>              :    // fetch control</span>
<span id="L286"><span class="lineNum">     286</span>              :    el2_ifu_ifc_ctl #(.pt(pt)) ifc (.*</span>
<span id="L287"><span class="lineNum">     287</span>              :                     );</span>
<span id="L288"><span class="lineNum">     288</span>              : </span>
<span id="L289"><span class="lineNum">     289</span>              :    // branch predictor</span>
<span id="L290"><span class="lineNum">     290</span>              :    if (pt.BTB_ENABLE==1) begin  : bpred</span>
<span id="L291"><span class="lineNum">     291</span>              :       el2_ifu_bp_ctl #(.pt(pt)) bp (.*);</span>
<span id="L292"><span class="lineNum">     292</span>              :    end</span>
<span id="L293"><span class="lineNum">     293</span>              :    else begin : bpred</span>
<span id="L294"><span class="lineNum">     294</span>              :       assign ifu_bp_hit_taken_f = '0;</span>
<span id="L295"><span class="lineNum">     295</span>              :       // verif wires</span>
<span id="L296"><span class="lineNum">     296</span>              :       logic btb_wr_en_way0, btb_wr_en_way1,dec_tlu_error_wb;</span>
<span id="L297"><span class="lineNum">     297</span>              :       logic [16+pt.BTB_BTAG_SIZE:0] btb_wr_data;</span>
<span id="L298"><span class="lineNum">     298</span>              :       assign btb_wr_en_way0 = '0;</span>
<span id="L299"><span class="lineNum">     299</span>              :       assign btb_wr_en_way1 = '0;</span>
<span id="L300"><span class="lineNum">     300</span>              :       assign btb_wr_data = '0;</span>
<span id="L301"><span class="lineNum">     301</span>              :       assign dec_tlu_error_wb ='0;</span>
<span id="L302"><span class="lineNum">     302</span>              :       assign ifu_bp_inst_mask_f = 1'b1;</span>
<span id="L303"><span class="lineNum">     303</span>              :    end</span>
<span id="L304"><span class="lineNum">     304</span>              : </span>
<span id="L305"><span class="lineNum">     305</span>              : </span>
<span id="L306"><span class="lineNum">     306</span>              : </span>
<span id="L307"><span class="lineNum">     307</span>              :    // aligner</span>
<span id="L308"><span class="lineNum">     308</span>              : </span>
<span id="L309"><span class="lineNum">     309</span>              :    el2_ifu_aln_ctl #(.pt(pt)) aln (</span>
<span id="L310"><span class="lineNum">     310</span>              :                                     .*</span>
<span id="L311"><span class="lineNum">     311</span>              :                                     );</span>
<span id="L312"><span class="lineNum">     312</span>              : </span>
<span id="L313"><span class="lineNum">     313</span>              : </span>
<span id="L314"><span class="lineNum">     314</span>              :    // icache</span>
<span id="L315"><span class="lineNum">     315</span>              :    el2_ifu_mem_ctl #(.pt(pt)) mem_ctl</span>
<span id="L316"><span class="lineNum">     316</span>              :      (.*,</span>
<span id="L317"><span class="lineNum">     317</span>              :       .ic_data_f(ic_data_f[31:0])</span>
<span id="L318"><span class="lineNum">     318</span>              :       );</span>
<span id="L319"><span class="lineNum">     319</span>              : </span>
<span id="L320"><span class="lineNum">     320</span>              : </span>
<span id="L321"><span class="lineNum">     321</span>              : </span>
<span id="L322"><span class="lineNum">     322</span>              :    // Performance debug info</span>
<span id="L323"><span class="lineNum">     323</span>              :    //</span>
<span id="L324"><span class="lineNum">     324</span>              :    //</span>
<span id="L325"><span class="lineNum">     325</span>              : `ifdef DUMP_BTB_ON</span>
<span id="L326"><span class="lineNum">     326</span>              :    logic              exu_mp_valid; // conditional branch mispredict</span>
<span id="L327"><span class="lineNum">     327</span>              :    logic exu_mp_way; // conditional branch mispredict</span>
<span id="L328"><span class="lineNum">     328</span>              :    logic exu_mp_ataken; // direction is actual taken</span>
<span id="L329"><span class="lineNum">     329</span>              :    logic exu_mp_boffset; // branch offsett</span>
<span id="L330"><span class="lineNum">     330</span>              :    logic exu_mp_pc4; // branch is a 4B inst</span>
<span id="L331"><span class="lineNum">     331</span>              :    logic exu_mp_call; // branch is a call inst</span>
<span id="L332"><span class="lineNum">     332</span>              :    logic exu_mp_ret; // branch is a ret inst</span>
<span id="L333"><span class="lineNum">     333</span>              :    logic exu_mp_ja; // branch is a jump always</span>
<span id="L334"><span class="lineNum">     334</span>              :    logic [1:0] exu_mp_hist; // new history</span>
<span id="L335"><span class="lineNum">     335</span>              :    logic [11:0] exu_mp_tgt; // target offset</span>
<span id="L336"><span class="lineNum">     336</span>              :    logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_mp_addr; // BTB/BHT address</span>
<span id="L337"><span class="lineNum">     337</span>              : </span>
<span id="L338"><span class="lineNum">     338</span>              :    assign exu_mp_valid = exu_mp_pkt.misp; // conditional branch mispredict</span>
<span id="L339"><span class="lineNum">     339</span>              :    assign exu_mp_ataken = exu_mp_pkt.ataken;  // direction is actual taken</span>
<span id="L340"><span class="lineNum">     340</span>              :    assign exu_mp_boffset = exu_mp_pkt.boffset;  // branch offset</span>
<span id="L341"><span class="lineNum">     341</span>              :    assign exu_mp_pc4 = exu_mp_pkt.pc4;  // branch is a 4B inst</span>
<span id="L342"><span class="lineNum">     342</span>              :    assign exu_mp_call = exu_mp_pkt.pcall;  // branch is a call inst</span>
<span id="L343"><span class="lineNum">     343</span>              :    assign exu_mp_ret = exu_mp_pkt.pret;  // branch is a ret inst</span>
<span id="L344"><span class="lineNum">     344</span>              :    assign exu_mp_ja = exu_mp_pkt.pja;  // branch is a jump always</span>
<span id="L345"><span class="lineNum">     345</span>              :    assign exu_mp_way = exu_mp_pkt.way;  // branch is a jump always</span>
<span id="L346"><span class="lineNum">     346</span>              :    assign exu_mp_hist[1:0] = exu_mp_pkt.hist[1:0];  // new history</span>
<span id="L347"><span class="lineNum">     347</span>              :    assign exu_mp_tgt[11:0]  = exu_mp_pkt.toffset[11:0] ;  // target offset</span>
<span id="L348"><span class="lineNum">     348</span>              :    assign exu_mp_addr[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  = exu_mp_index[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ;  // BTB/BHT address</span>
<span id="L349"><span class="lineNum">     349</span>              : </span>
<span id="L350"><span class="lineNum">     350</span>              :    logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] btb_rd_addr_f;</span>
<span id="L351"><span class="lineNum">     351</span>              :  `define DEC `CPU_TOP.dec</span>
<span id="L352"><span class="lineNum">     352</span>              :  `define EXU `CPU_TOP.exu</span>
<span id="L353"><span class="lineNum">     353</span>              :    el2_btb_addr_hash f2hash(.pc(ifc_fetch_addr_f[pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO]), .hash(btb_rd_addr_f[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]));</span>
<span id="L354"><span class="lineNum">     354</span>              :    logic [31:0] mppc_ns, mppc;</span>
<span id="L355"><span class="lineNum">     355</span>              :    logic        exu_flush_final_d1;</span>
<span id="L356"><span class="lineNum">     356</span>              :    assign mppc_ns[31:1] = `EXU.i0_flush_upper_x ? `EXU.exu_i0_pc_x : `EXU.dec_i0_pc_d;</span>
<span id="L357"><span class="lineNum">     357</span>              :    assign mppc_ns[0] = 1'b0;</span>
<span id="L358"><span class="lineNum">     358</span>              :    rvdff #(33)  junk_ff (.*, .clk(active_clk), .din({mppc_ns[31:0], exu_flush_final}), .dout({mppc[31:0], exu_flush_final_d1}));</span>
<span id="L359"><span class="lineNum">     359</span>              :    logic  tmp_bnk;</span>
<span id="L360"><span class="lineNum">     360</span>              :    assign tmp_bnk = bpred.bp.btb_sel_f[1];</span>
<span id="L361"><span class="lineNum">     361</span>              : </span>
<span id="L362"><span class="lineNum">     362</span>              :    always @(negedge clk) begin</span>
<span id="L363"><span class="lineNum">     363</span>              :       if(`DEC.tlu.mcyclel[31:0] == 32'h0000_0010) begin</span>
<span id="L364"><span class="lineNum">     364</span>              :          $display("BTB_CONFIG: %d",pt.BTB_SIZE);</span>
<span id="L365"><span class="lineNum">     365</span>              :          `ifndef BP_NOGSHARE</span>
<span id="L366"><span class="lineNum">     366</span>              :          $display("BHT_CONFIG: %d gshare: 1",pt.BHT_SIZE);</span>
<span id="L367"><span class="lineNum">     367</span>              :          `else</span>
<span id="L368"><span class="lineNum">     368</span>              :          $display("BHT_CONFIG: %d gshare: 0",pt.BHT_SIZE);</span>
<span id="L369"><span class="lineNum">     369</span>              :          `endif</span>
<span id="L370"><span class="lineNum">     370</span>              :          $display("RS_CONFIG: %d", pt.RET_STACK_SIZE);</span>
<span id="L371"><span class="lineNum">     371</span>              :       end</span>
<span id="L372"><span class="lineNum">     372</span>              :        if(exu_flush_final_d1 &amp; ~(dec_tlu_br0_r_pkt.br_error | dec_tlu_br0_r_pkt.br_start_error) &amp; (exu_mp_pkt.misp | exu_mp_pkt.ataken))</span>
<span id="L373"><span class="lineNum">     373</span>              :          $display("%7d BTB_MP  : index: %0h bank: %0h call: %b ret: %b ataken: %b hist: %h valid: %b tag: %h targ: %h eghr: %b pred: %b ghr_index: %h brpc: %h way: %h", `DEC.tlu.mcyclel[31:0]+32'ha, exu_mp_addr[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO], 1'b0, exu_mp_call, exu_mp_ret, exu_mp_ataken, exu_mp_hist[1:0], exu_mp_valid, exu_mp_btag[pt.BTB_BTAG_SIZE-1:0], {exu_flush_path_final[31:1], 1'b0}, exu_mp_eghr[pt.BHT_GHR_SIZE-1:0], exu_mp_valid, bpred.bp.bht_wr_addr0, mppc[31:0], exu_mp_pkt.way);</span>
<span id="L374"><span class="lineNum">     374</span>              : </span>
<span id="L375"><span class="lineNum">     375</span>              :      for(int i = 0; i &lt; 8; i++) begin</span>
<span id="L376"><span class="lineNum">     376</span>              :       if(ifu_bp_valid_f[i] &amp; ifc_fetch_req_f)</span>
<span id="L377"><span class="lineNum">     377</span>              :         $display("%7d BTB_HIT : index: %0h bank: %0h call: %b ret: %b taken: %b strength: %b tag: %h targ: %0h ghr: %4b ghr_index: %h way: %h", `DEC.tlu.mcyclel[31:0]+32'ha,btb_rd_addr_f[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO],bpred.bp.btb_sel_f[1], bpred.bp.btb_rd_call_f, bpred.bp.btb_rd_ret_f, ifu_bp_hist1_f[tmp_bnk], ifu_bp_hist0_f[tmp_bnk], bpred.bp.fetch_rd_tag_f[pt.BTB_BTAG_SIZE-1:0], {ifu_bp_btb_target_f[31:1], 1'b0}, bpred.bp.fghr[pt.BHT_GHR_SIZE-1:0], bpred.bp.bht_rd_addr_f, ifu_bp_way_f[tmp_bnk]);</span>
<span id="L378"><span class="lineNum">     378</span>              :      end</span>
<span id="L379"><span class="lineNum">     379</span>              :       if(dec_tlu_br0_r_pkt.valid &amp; ~(dec_tlu_br0_r_pkt.br_error | dec_tlu_br0_r_pkt.br_start_error))</span>
<span id="L380"><span class="lineNum">     380</span>              :         $display("%7d BTB_UPD0: ghr_index: %0h bank: %0h hist: %h  way: %h", `DEC.tlu.mcyclel[31:0]+32'ha,bpred.bp.br0_hashed_wb[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO],{dec_tlu_br0_r_pkt.middle}, dec_tlu_br0_r_pkt.hist, dec_tlu_br0_r_pkt.way);</span>
<span id="L381"><span class="lineNum">     381</span>              : </span>
<span id="L382"><span class="lineNum">     382</span>              :       if(dec_tlu_br0_r_pkt.br_error | dec_tlu_br0_r_pkt.br_start_error)</span>
<span id="L383"><span class="lineNum">     383</span>              :         $display("%7d BTB_ERR0: index: %0h bank: %0h start: %b rfpc: %h way: %h", `DEC.tlu.mcyclel[31:0]+32'ha,exu_i0_br_index_r[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO],1'b0, dec_tlu_br0_r_pkt.br_start_error, {exu_flush_path_final[31:1], 1'b0}, dec_tlu_br0_r_pkt.way);</span>
<span id="L384"><span class="lineNum">     384</span>              :    end // always @ (negedge clk)</span>
<span id="L385"><span class="lineNum">     385</span>              :       function [1:0] encode4_2;</span>
<span id="L386"><span class="lineNum">     386</span>              :       input [3:0] in;</span>
<span id="L387"><span class="lineNum">     387</span>              : </span>
<span id="L388"><span class="lineNum">     388</span>              :       encode4_2[1] = in[3] | in[2];</span>
<span id="L389"><span class="lineNum">     389</span>              :       encode4_2[0] = in[3] | in[1];</span>
<span id="L390"><span class="lineNum">     390</span>              : </span>
<span id="L391"><span class="lineNum">     391</span>              :    endfunction</span>
<span id="L392"><span class="lineNum">     392</span>              : `endif</span>
<span id="L393"><span class="lineNum">     393</span>              : endmodule // el2_ifu</span>
        </pre>
</td>
</tr>
</table>

</body>
</html>
